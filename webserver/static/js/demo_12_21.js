// Generated by CoffeeScript 2.3.1
(function() {
  var applyForce, box, box_material, boxes, camera, direction, ground, ground_material, initScene, light, mesh, mouse_position, onResize, projector, render, render_stats, renderer, scale, scene, setMousePosition, stepX;

  console.log("demo_12.21 Rigid body - Physijs");

  camera = null;

  scene = null;

  renderer = null;

  mesh = null;

  stepX = null;

  direction = 1;

  "use strict";

  scale = chroma.scale(["white", "blue", "red", "yellow"]);

  Physijs.scripts.worker = "/static/js/libs/physijs_worker.js";

  Physijs.scripts.ammo = "/static/js/libs/ammo.js";

  initScene = [];

  render = [];

  applyForce = [];

  setMousePosition = [];

  mouse_position = [];

  ground_material = [];

  projector = [];

  box_material = [];

  renderer = [];

  render_stats = [];

  scene = [];

  ground = [];

  light = [];

  camera = [];

  box = [];

  boxes = [];

  // 实时渲染
  render = function() {
    render_stats.update();
    requestAnimationFrame(render);
    renderer.render(scene, camera);
    ground.rotation.x += 0.002 * direction;
    if (ground.rotation.x < -0.4) {
      direction = 1;
    }
    if (ground.rotation.x > 0.4) {
      direction = -1;
    }
    ground.__dirtyRotation = true;
    return scene.simulate(void 0, 1);
  };

  initScene = function() {
    var borderBottom, borderLeft, borderRight, borderTop, controls, gui, meshes, webGLRenderer;
    // 场景
    scene = new Physijs.Scene;
    scene.setGravity(new THREE.Vector3(0, -90, 0));
    
    // 摄像机
    camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(80, 60, 80);
    camera.lookAt(scene.position);
    scene.add(camera);
    
    // 渲染器
    webGLRenderer = new THREE.WebGLRenderer();
    webGLRenderer.antialias = true;
    webGLRenderer.setClearColor(new THREE.Color(0x000000));
    webGLRenderer.setSize(window.innerWidth, window.innerHeight);
    renderer = webGLRenderer;
    $("#viewport").append(renderer.domElement);
    //灯光
    light = new THREE.SpotLight(0xFFFFFF);
    light.position.set(20, 100, 50);
    scene.add(light);
    
    // 材质
    ground_material = Physijs.createMaterial(new THREE.MeshPhongMaterial({
      map: THREE.ImageUtils.loadTexture("/static/pictures/assets/textures/general/floor-wood.jpg")
    }), .9, .6);
    ground_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
    ground_material.map.repeat.set(4, 8);
    //地面
    ground = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 1, 130), ground_material, 0);
    ground.receiveShadow = true;
    borderLeft = new Physijs.BoxMesh(new THREE.BoxGeometry(2, 6, 130), ground_material, 0);
    borderLeft.position.x = -31;
    borderLeft.position.y = 2;
    ground.add(borderLeft);
    borderRight = new Physijs.BoxMesh(new THREE.BoxGeometry(2, 6, 130), ground_material, 0);
    borderRight.position.x = 31;
    borderRight.position.y = 2;
    ground.add(borderRight);
    borderBottom = new Physijs.BoxMesh(new THREE.BoxGeometry(64, 6, 2), ground_material, 0);
    borderBottom.position.z = 65;
    borderBottom.position.y = 2;
    ground.add(borderBottom);
    borderTop = new Physijs.BoxMesh(new THREE.BoxGeometry(64, 6, 2), ground_material, 0);
    borderTop.position.z = -65;
    borderTop.position.y = 2;
    ground.add(borderTop);
    scene.add(ground);
    meshes = [];
    
    // 控制条
    controls = new function() {
      this.cubeRestitution = 0.4;
      this.cubeFriction = 0.4;
      this.sphereRestitution = 0.9;
      this.sphereFriction = 0.1;
      this.clearMeshes = function() {
        meshes.forEach(function(e) {
          return scene.remove(e);
        });
        return meshes = [];
      };
      this.addSpheres = function() {
        var colorSphere, i, j, results;
        colorSphere = scale(Math.random()).hex();
        results = [];
        for (i = j = 0; j <= 4; i = ++j) {
          box = new Physijs.SphereMesh(new THREE.SphereGeometry(2, 20), Physijs.createMaterial(new THREE.MeshPhongMaterial({
            color: colorSphere,
            opacity: 0.8,
            transparent: true
          }), controls.sphereFriction, controls.sphereRestitution));
          box.position.set(Math.random() * 50 - 25, 20 + Math.random() * 5, Math.random() * 50 - 25);
          meshes.push(box);
          results.push(scene.add(box));
        }
        return results;
      };
      this.addCubes = function() {
        var colorBox, i, j, results;
        colorBox = scale(Math.random()).hex();
        results = [];
        for (i = j = 0; j <= 4; i = ++j) {
          box = new Physijs.BoxMesh(new THREE.BoxGeometry(4, 4, 4), Physijs.createMaterial(new THREE.MeshPhongMaterial({
            color: colorBox,
            opacity: 0.8,
            transparent: true
          }), controls.cubeFriction, controls.cubeRestitution));
          box.position.set(Math.random() * 50 - 25, 20 + Math.random() * 5, Math.random() * 50 - 25);
          box.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
          meshes.push(box);
          results.push(scene.add(box));
        }
        return results;
      };
      return this;
    };
    
    // UI
    gui = new dat.GUI();
    gui.add(controls, "cubeRestitution", 0, 1);
    gui.add(controls, "cubeFriction", 0, 1);
    gui.add(controls, "sphereRestitution", 0, 1);
    gui.add(controls, "sphereFriction", 0, 1);
    gui.add(controls, "addCubes");
    gui.add(controls, "addSpheres");
    gui.add(controls, "clearMeshes");
    requestAnimationFrame(render);
    scene.simulate();
    
    // 状态条
    render_stats = new Stats();
    render_stats.setMode(0);
    render_stats.domElement.style.position = "absolute";
    render_stats.domElement.style.top = "1px";
    render_stats.domElement.style.zIndex = 100;
    return $("#viewport").append(render_stats.domElement);
  };

  //屏幕适配
  onResize = function() {
    console.log("onResize");
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    return renderer.setSize(window.innerWidth, window.innerHeight);
  };

  window.onload = initScene;

  window.addEventListener("resize", onResize, false);

}).call(this);
