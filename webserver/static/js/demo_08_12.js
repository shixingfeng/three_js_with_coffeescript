// Generated by CoffeeScript 2.3.1
(function() {
  var camera, init, onResize, renderer, step;

  console.log("demo_08.12 Merge objects");

  camera = null;

  renderer = null;

  step = 0;

  //屏幕适配
  onResize = function() {
    console.log("onResize");
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    return renderer.setSize(window.innerWidth, window.innerHeight);
  };

  init = function() {
    var addcube, controls, createMesh, cubeMaterial, gui, initStats, knot, renderScene, scene, stats, webGLRenderer;
    // 场景
    scene = new THREE.Scene();
    
    // 摄像机
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.x = 0;
    camera.position.y = 40;
    camera.position.z = 50;
    camera.lookAt(scene.position);
    
    // 渲染器
    webGLRenderer = new THREE.WebGLRenderer();
    webGLRenderer.setClearColor(new THREE.Color(0x00000, 1.0));
    webGLRenderer.setSize(window.innerWidth, window.innerHeight);
    webGLRenderer.shadowMapEnabled = true;
    renderer = webGLRenderer;
    
    // 材质
    createMesh = function(geom) {
      var mesh, meshMaterial;
      meshMaterial = new THREE.MeshBasicMaterial({
        vertexColors: THREE.VertexColors,
        wireframe: true,
        wireframeLinewidth: 2,
        color: 0xaaaaaa
      });
      meshMaterial.side = THREE.DoubleSide;
      mesh = new THREE.Mesh(geom, meshMaterial);
      return mesh;
    };
    cubeMaterial = new THREE.MeshNormalMaterial({
      color: 0x00ff00,
      transparent: true,
      opacity: 0.5
    });
    addcube = function() {
      var cube, cubeGeometry, cubeSize;
      cubeSize = 1.0;
      cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
      cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cube.castShadow = true;
      cube.position.x = -60 + Math.round(Math.random() * 100);
      cube.position.y = Math.round(Math.random() * 10);
      cube.position.z = -150 + Math.round(Math.random() * 175);
      return cube;
    };
    //网格物体
    knot = createMesh(new THREE.TorusKnotGeometry(10, 1, 64, 8, 2, 3, 1));
    scene.add(knot);
    // 控制条
    controls = new function() {
      this.cameraNear = camera.near;
      this.cameraFar = camera.far;
      this.rotationSpeed = 0.02;
      this.combined = false;
      this.numberOfObjects = 500;
      this.redraw = function() {
        var cubeMesh, geometry, i, j, k, ref, ref1, results, toRemove;
        toRemove = [];
        scene.traverse(function(e) {
          if (e instanceof THREE.Mesh) {
            return toRemove.push(e);
          }
        });
        toRemove.forEach(function(e) {
          return scene.remove(e);
        });
        if (controls.combined) {
          geometry = new THREE.Geometry();
          for (i = j = 0, ref = controls.numberOfObjects - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
            cubeMesh = addcube();
            cubeMesh.updateMatrix();
            geometry.merge(cubeMesh.geometry, cubeMesh.matrix);
          }
          return scene.add(new THREE.Mesh(geometry, cubeMaterial));
        } else {
          results = [];
          for (i = k = 0, ref1 = controls.numberOfObjects - 1; (0 <= ref1 ? k <= ref1 : k >= ref1); i = 0 <= ref1 ? ++k : --k) {
            results.push(scene.add(controls.addCube()));
          }
          return results;
        }
      };
      this.addCube = addcube;
      this.outputObjects = function() {
        return console.log(scene.children);
      };
      return this;
    };
    // UI呈现
    gui = new dat.GUI();
    gui.add(controls, "numberOfObjects", 0, 20000);
    gui.add(controls, "combined").onChange(controls.redraw);
    gui.add(controls, "redraw");
    // 执行
    controls.redraw();
    
    // 状态条
    initStats = function() {
      var stats;
      stats = new Stats();
      stats.setMode(0);
      stats.domElement.style.position = "absolute";
      stats.domElement.style.left = "0px";
      stats.domElement.style.top = "0px";
      $("#Stats-output").append(stats.domElement);
      return stats;
    };
    // 实时渲染
    renderScene = function() {
      stats.update();
      knot.rotation.y = step += 0.01;
      requestAnimationFrame(renderScene);
      renderer.render(scene, camera);
      return $("#WebGL-output").append(renderer.domElement);
    };
    stats = initStats();
    renderScene();
    return window.addEventListener("resize", onResize, false);
  };

  window.onload = init;

}).call(this);
